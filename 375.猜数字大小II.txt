我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。

示例:

n = 10, 我选择了8.

第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。

游戏结束。8 就是我选的数字。

你最终要支付 5 + 7 + 9 = 21 块钱。

给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。

【思路】
dp[i][j]是 依次以从i到j的数字作为分割点(猜的数)，必定赢的游戏所用钱的最小值。

状态转移方程：
i i+1 i+2 ... ... j-2 j-1 j
i<k<j
以k为分割点对应的：dp1=max(dp[i][k-1],dp[k+1][j])+k
特别地,以i为分割点：dp0=i+dp[i+1][j];以j为分割点: dp2=j+dp[i][j-1]
dp[i][j]=min(dp0,dp1,dp2)
从下往上，从左往右遍历
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n+1,vector<int>(n+1,INT_MAX));
        for(int i=1;i<=n;i++)
            dp[i][i]=0;
        for(int i=n-1;i>0;i--){
            for(int j=i+1;j<=n;j++){
                for(int k=i+1;k<j;k++)
                    dp[i][j]=min(dp[i][j],max(dp[i][k-1],dp[k+1][j])+k);
                dp[i][j]=min({dp[i][j],i+dp[i+1][j],j+dp[i][j-1]});
            }
        }
        return dp[1][n];
    }
};

