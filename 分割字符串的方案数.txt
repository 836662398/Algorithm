给你一个二进制串 s （一个只包含 0 和 1 的字符串）,我们可以将 s 分割成 3 个 非空 字符串 s1, s2, s3 （s1 + s2 + s3 = s）.

请你返回分割 s 的方案数，满足 s1，s2 和 s3 中字符 '1' 的数目相同。

由于答案可能很大，请将它对 10^9 + 7 取余后返回。

示例 1：

输入：s = "10101"
输出：4
解释：总共有 4 种方法将 s 分割成含有 '1' 数目相同的三个子字符串。
"1|010|1"
"1|01|01"
"10|10|1"
"10|1|01"

示例 2：

输入：s = "1001"
输出：0

示例 3：

输入：s = "0000"
输出：3
解释：总共有 3 种分割 s 的方法。
"0|0|00"
"0|00|0"
"00|0|0"

示例 4：

输入：s = "100100010100110"
输出：12

提示：

    s[i] == '0' 或者 s[i] == '1'
    3 <= s.length <= 10^5

【思路】数学 + 哈希表
求出第一块1 和 第二块1之前的0个数，以及 第二块1和第三块1之间的0个数。
用哈希表记录每个1的下标，即可快速求出上述0个数。
class Solution {
   public:
    int numWays(string s) {
        const int MOD = 1e9 + 7;
        int n = s.size(), cnt = 0;
        unordered_map<int, int> memo;
        for (int i = 0; i < n; i++) {
            if (s[i] == '1') {
                cnt++;
                memo[cnt] = i;
            }
        }
        if (n < 3 || cnt % 3 != 0)
            return 0;
        if (cnt == 0)
            return 1ll * (n - 1) % MOD * (n - 2) % MOD / 2;
        int t = cnt / 3;
        return 1ll * (memo[t + 1] - memo[t]) % MOD *
               (memo[2 * t + 1] - memo[2 * t]) % MOD;
    }
};