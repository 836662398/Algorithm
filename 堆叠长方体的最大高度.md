给你 `n` 个长方体 `cuboids` ，其中第 `i` 个长方体的长宽高表示为 `cuboids[i] = [widthi, lengthi, heighti]`（**下标从 0 开始**）。请你从 `cuboids` 选出一个 **子集** ，并将它们堆叠起来。

如果 `widthi <= widthj` 且 `lengthi <= lengthj` 且 `heighti <= heightj` ，你就可以将长方体 `i` 堆叠在长方体 `j` 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。

返回 **堆叠长方体** `cuboids` 可以得到的 **最大高度** 。

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/12/image.jpg)**

```
输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]]
输出：190
解释：
第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。
第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。
第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。
总高度是 95 + 50 + 45 = 190 。
```

**示例 2：**

```
输入：cuboids = [[38,25,45],[76,35,3]]
输出：76
解释：
无法将任何长方体放在另一个上面。
选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。
```

**示例 3：**

```
输入：cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]
输出：102
解释：
重新排列长方体后，可以看到所有长方体的尺寸都相同。
你可以把 11x7 的一面朝下，这样它们的高度就是 17 。
堆叠长方体的最大高度为 6 * 17 = 102 。
```

 

**提示：**

- `n == cuboids.length`
- `1 <= n <= 100`
- `1 <= widthi, lengthi, heighti <= 100`

------

【思路】DP

考虑两个长方体，假设其三边分别为(a1,b1,c1)和(a2,b2,c2)。这里不妨假设a1≤b1≤c1，a2≤b2≤c2。

我们可以发现，假设两个长方体能够拼接到一起（不妨假设第一个长方体较小），则必然有：

a1≤a2,b1≤b2,c1≤c2

进一步地，我们可以发现，如果两个长方体是能够拼接在一起的，则它们可以从任何一个面进行拼接。

本题允许我们任意旋转长方体，看起来我们需要讨论6种排列情况，但实际上，因为我们希望高度尽可能高，所以根据上面的观察，我们应该选择从较短的两条边组成的面进行拼接。

因此，我们进行两次排序：

1. 将每个长方体的三边升序排列。
2. 将所有长方体升序排列（这里是按照长宽高递增来考虑的，显然，这与题目中的描述是等价的）。因为最优解下，长方体从小到大排列的次序必然是升序排列，所以这一步排序可以保证我们能够得到最优解。

之后，我们就可以进行朴素的O(N^2)动态规划了。对于第i个长方体，我们依次考虑第[1…i−1]个长方体，看看是否能够将第i个长方体拼接在它的下方，然后更新当前的最大值。

```C++
class Solution {
public:
    int maxHeight(vector<vector<int>>& cuboids) {
        int n = cuboids.size();
        for (auto &c : cuboids)
            sort(c.begin(), c.end());
        sort(cuboids.begin(), cuboids.end());
        vector<int> dp(n);
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j)
                if (cuboids[j][1] <= cuboids[i][1] && cuboids[j][2] <= cuboids[i][2])
                    dp[i] = max(dp[i], dp[j]);
            dp[i] += cuboids[i][2];
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```